/**
 * BarChart — Vertical or horizontal bar chart rendered with D3 into an SVG.
 *
 * ── BOILERPLATE: NO CHANGES NEEDED ─────────────────────────────────────────
 * Chart components are data-agnostic — they render whatever data array is
 * passed via props. When swapping datasets, update the page components
 * (src/pages/) that prepare and pass data to these charts, not the charts
 * themselves. The only reason to modify a chart is to change its visual
 * style or add new interactive features.
 * ────────────────────────────────────────────────────────────────────────────
 *
 * WHAT IT DOES
 * Renders a simple bar chart that can be oriented either vertically (default)
 * or horizontally. Supports optional bar-click selection (highlight one bar,
 * dim the rest), animated entrance transitions, and automatic label
 * truncation / rotation when labels don't fit.
 *
 * PROPS
 * @param {Array<Object>} data
 *   Array of plain objects. Each object must contain at least the keys
 *   specified by `xKey` (category label) and `yKey` (numeric value).
 *   Example: [{ label: 'Trucks', value: 42000000 }, ...]
 *
 * @param {string} [xKey='label']
 *   Property name used for the category axis (x-axis in vertical mode,
 *   y-axis in horizontal mode).
 *
 * @param {string} [yKey='value']
 *   Property name used for the value axis.
 *
 * @param {string} [color=CHART_COLORS[0]]
 *   Fill color for bars. When a bar is not selected, it's rendered with
 *   25% opacity (`${color}40`).
 *
 * @param {boolean} [horizontal=false]
 *   If true, bars grow left-to-right and labels appear on the y-axis.
 *   If false, bars grow bottom-to-top with labels on the x-axis.
 *
 * @param {Function} [formatValue=formatCurrency]
 *   Formatter for value labels shown on or above each bar.
 *
 * @param {Function} [onBarClick]
 *   Optional callback invoked with the clicked datum. Used together with
 *   `selectedBar` for click-to-filter interactions.
 *
 * @param {string} [selectedBar]
 *   Value of `xKey` for the currently selected bar. Non-selected bars are
 *   dimmed. Pass `null`/`undefined` to show all bars at full opacity.
 *
 * @param {number} [maxBars=15]
 *   Maximum number of bars displayed. Data beyond this limit is sliced off.
 *   NOTE: This is a visual cap — the parent should pre-sort data by
 *   importance/value so the most meaningful items appear first.
 *
 * @param {boolean} [animate=true]
 *   Whether bars animate in on first render (600ms staggered transition).
 *
 * EDGE CASES & LIMITATIONS
 * - If `data` is empty or container width is 0, nothing renders.
 * - Labels longer than 20 characters are truncated with an ellipsis in
 *   vertical mode; in horizontal mode they're truncated to fit the
 *   available left margin.
 * - Vertical x-axis labels auto-rotate -35deg when they'd overlap.
 * - The component sets a `minHeight` on the container in horizontal mode
 *   to ensure each bar gets ~32px of vertical space.
 */
import { useRef, useEffect } from 'react'
import * as d3 from 'd3'
import { useChartResize, getResponsiveFontSize } from '@/lib/useChartResize'
import { CHART_COLORS, formatCurrency } from '@/lib/chartColors'

/** Half-length of axis tick marks (extends TICK_HALF px above and below the axis line). */
const TICK_HALF = 5

export default function BarChart({
  data = [],
  xKey = 'label',
  yKey = 'value',
  color = CHART_COLORS[0],
  horizontal = false,
  formatValue = formatCurrency,
  onBarClick,
  selectedBar,
  maxBars = 15,
  animate = true,
}) {
  const containerRef = useRef(null)
  const svgRef = useRef(null)
  const { width, height: containerHeight, isFullscreen } = useChartResize(containerRef)

  useEffect(() => {
    if (!data.length || !width) return

    const FS = getResponsiveFontSize(width, isFullscreen)
    const charW = FS * 0.55

    // Enforce maxBars cap — only the first `maxBars` items are rendered.
    const displayData = data.slice(0, maxBars)
    const maxLabelLen = d3.max(displayData, (d) => (d[xKey] || '').length) || 0
    const dynamicLeft = horizontal
      ? Math.min(width * 0.4, Math.max(160, maxLabelLen * charW + 20))
      : 16
    // Estimate if vertical labels need rotation (before scale is built)
    const approxBandwidth = horizontal ? 0 : (width - 32) / displayData.length * 0.7
    const vLabelRotated = !horizontal && maxLabelLen * 9 > approxBandwidth
    const margin = horizontal
      ? { top: 8, right: 80, bottom: 24, left: dynamicLeft }
      : { top: 24, right: 16, bottom: vLabelRotated ? 100 : 48, left: 16 }

    const defaultH = horizontal ? Math.max(220, displayData.length * 32 + margin.top + margin.bottom) : 320
    // For horizontal bars, always use at least defaultH so labels don't overlap
    const height = horizontal
      ? Math.max(defaultH, containerHeight > 100 ? containerHeight : defaultH)
      : (containerHeight > 100 ? containerHeight : defaultH)
    const innerW = Math.max(1, width - margin.left - margin.right)
    const innerH = Math.max(1, height - margin.top - margin.bottom)

    const svg = d3.select(svgRef.current)
    svg.selectAll('*').remove()
    svg.attr('width', width).attr('height', height)

    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`)

    if (horizontal) {
      const x = d3.scaleLinear()
        .domain([0, d3.max(displayData, (d) => d[yKey]) || 1])
        .nice()
        .range([0, innerW])

      const y = d3.scaleBand()
        .domain(displayData.map((d) => d[xKey]))
        .range([0, innerH])
        .padding(0.3)

      // Y-axis line
      g.append('line')
        .attr('x1', 0).attr('x2', 0).attr('y1', 0).attr('y2', innerH)
        .attr('stroke', '#9ca3af')

      // X-axis line
      g.append('line')
        .attr('x1', 0).attr('x2', innerW).attr('y1', innerH).attr('y2', innerH)
        .attr('stroke', '#9ca3af')

      // Bars
      g.selectAll('.bar').data(displayData).enter()
        .append('rect')
        .attr('class', 'bar')
        .attr('y', (d) => y(d[xKey]))
        .attr('height', y.bandwidth())
        .attr('x', 0)
        .attr('rx', 3)
        // Dim non-selected bars to 25% opacity via hex alpha suffix
        .attr('fill', (d) => (selectedBar && d[xKey] !== selectedBar ? `${color}40` : color))
        .attr('cursor', onBarClick ? 'pointer' : 'default')
        .attr('width', 0)
        .on('click', (e, d) => onBarClick?.(d))
        .transition()
        .duration(animate ? 600 : 0)
        .delay((d, i) => (animate ? i * 30 : 0))
        .attr('width', (d) => x(d[yKey]))

      // Value labels — inside bar if it would overflow, outside otherwise
      const rightMarginPx = margin.right
      g.selectAll('.val-label').data(displayData).enter()
        .append('text')
        .attr('y', (d) => y(d[xKey]) + y.bandwidth() / 2)
        .attr('dy', '0.35em')
        .attr('font-size', `${FS}px`)
        .each(function (d) {
          const barW = x(d[yKey])
          const labelText = formatValue(d[yKey])
          const labelW = labelText.length * charW // approx char width
          const overflows = barW + labelW + 8 > innerW + rightMarginPx
          d3.select(this)
            .attr('x', overflows ? barW - 8 : barW + 4)
            .attr('text-anchor', overflows ? 'end' : 'start')
            .attr('fill', overflows ? 'white' : 'var(--color-text-secondary)')
            .attr('font-weight', overflows ? '600' : 'normal')
            .text(labelText)
        })
        .attr('opacity', 0)
        .transition()
        .delay(animate ? 400 : 0)
        .duration(300)
        .attr('opacity', 1)

      // Y Axis (centered tick marks)
      const yAxisH = g.append('g')
        .call(d3.axisLeft(y).tickSize(0))
      yAxisH.select('.domain').remove()
      yAxisH.selectAll('.tick').append('line')
        .attr('x1', -TICK_HALF).attr('x2', 0)
        .attr('stroke', '#9ca3af')
      // Fit labels: shrink font or truncate only if needed
      const labelSpace = dynamicLeft - 20 // available px for label text
      yAxisH.selectAll('.tick text')
        .attr('fill', 'var(--color-text-secondary)')
        .attr('dx', '-0.4em')
        .each(function () {
          const text = d3.select(this).text()
          const fits = text.length * charW <= labelSpace
          if (fits) {
            d3.select(this).attr('font-size', `${FS}px`)
          } else {
            d3.select(this).attr('font-size', `${FS}px`)
            const maxChars = Math.floor(labelSpace / charW)
            d3.select(this).text(text.slice(0, maxChars - 1) + '…')
          }
        })

    } else {
      const x = d3.scaleBand()
        .domain(displayData.map((d) => d[xKey]))
        .range([0, innerW])
        .padding(0.3)

      const y = d3.scaleLinear()
        .domain([0, d3.max(displayData, (d) => d[yKey]) || 1])
        .nice()
        .range([innerH, 0])

      // X-axis line
      g.append('line')
        .attr('x1', 0).attr('x2', innerW).attr('y1', innerH).attr('y2', innerH)
        .attr('stroke', '#9ca3af')

      // Bars
      g.selectAll('.bar').data(displayData).enter()
        .append('rect')
        .attr('class', 'bar')
        .attr('x', (d) => x(d[xKey]))
        .attr('width', x.bandwidth())
        .attr('rx', 3)
        .attr('fill', (d) => (selectedBar && d[xKey] !== selectedBar ? `${color}40` : color))
        .attr('cursor', onBarClick ? 'pointer' : 'default')
        .attr('y', innerH)
        .attr('height', 0)
        .on('click', (e, d) => onBarClick?.(d))
        .transition()
        .duration(animate ? 600 : 0)
        .delay((d, i) => (animate ? i * 30 : 0))
        .attr('y', (d) => y(d[yKey]))
        .attr('height', (d) => innerH - y(d[yKey]))

      // Value labels above each bar
      g.selectAll('.val-label').data(displayData).enter()
        .append('text')
        .attr('x', (d) => x(d[xKey]) + x.bandwidth() / 2)
        .attr('text-anchor', 'middle')
        .attr('font-size', `${FS}px`)
        .attr('fill', 'var(--color-text-secondary)')
        .text((d) => formatValue(d[yKey]))
        .attr('y', innerH)
        .attr('opacity', 0)
        .transition()
        .duration(animate ? 600 : 0)
        .delay((d, i) => (animate ? i * 30 : 0))
        .attr('y', (d) => y(d[yKey]) - 6)
        .attr('opacity', 1)

      // X Axis (tick marks only below axis)
      const xAxisV = g.append('g')
        .attr('transform', `translate(0,${innerH})`)
        .call(d3.axisBottom(x).tickSize(0))
      xAxisV.select('.domain').remove()
      xAxisV.selectAll('.tick').append('line')
        .attr('y1', 0).attr('y2', TICK_HALF)
        .attr('stroke', '#9ca3af')
      // Check if any label needs rotation
      const longestLabel = d3.max(displayData, (d) => (d[xKey] || '').length) || 0
      const needsRotation = longestLabel * charW > x.bandwidth()

      xAxisV.selectAll('.tick text')
        .attr('font-size', `${FS}px`)
        .attr('fill', 'var(--color-text-secondary)')
        .attr('dy', needsRotation ? '0.5em' : '1.2em')
        .attr('dx', needsRotation ? '-0.5em' : null)
        .attr('transform', needsRotation ? 'rotate(-35)' : null)
        .attr('text-anchor', needsRotation ? 'end' : 'middle')
        .each(function () {
          const text = d3.select(this).text()
          if (text.length > 20) d3.select(this).text(text.slice(0, 18) + '…')
        })
    }

  }, [data, width, containerHeight, isFullscreen, xKey, yKey, color, horizontal, selectedBar, maxBars, animate])

  // In horizontal mode, set a minimum height so each bar gets enough space
  // (~32px per bar). This allows the parent grid cell to grow accordingly.
  const displayCount = Math.min(data.length, maxBars)
  const minH = horizontal ? Math.max(220, displayCount * 32 + 32) : undefined

  return (
    <div ref={containerRef} className="w-full" style={{ minHeight: minH }}>
      <svg ref={svgRef} className="w-full" />
    </div>
  )
}
